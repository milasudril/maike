<?xml version="1.0"?>
<document title="Maike 2.0 user guide">
	<copyright>
		<author name="Torbjörn Rathsman">
			<year value="2021" />
		</author>
	</copyright>
	<resources>
		<link rel="stylesheet" href="./format.css" />
	</resources>
	<prelims>
		<tableofcontents/>
	</prelims>
	<main>
		<chapter title="Introduction" id="Introduction">
			<p>Maike is a build system based on scanning of source files. To construct the dependency graph, Maike uses embedded JSON data to control the compilation process. This allows for a minimal amount makefile maintanence, since when a new file is added to the project, dependencies form that file will be maintained by the file itself. This is also true for interfaces with a separate implementation file. The interface file may point to the implementation file, which will be used when linking an application that uses the particular interfafce.</p>

			<p>Maike guarantees that your project does not have any file-level cyclic dependencies. In case a cyclic dependency is detected, the build job will fail. Also, a broken dependency graph will result in a build error.</p>


			<section title="Language support" id="lang_support">
				<p>The main focus of Maike is to support C and C++, but it is also possible to use with other languages. For C and C++, there is a build-in quick-and-dirty C preprocessor parser that extracts include file references. It is also possible to write extensions that returns source file information on <code>stdout</code>. For simple conversions (i.e converting between image formats), it is possible to define a mapping between source filename extension, and target filename extension, together with a recipe that should be used for this particular conversion.</p>
			</section>

			<section title="Host system requirements" id="sysreq">
				<p>Maike is being developed and tested on a GNU/Linux desktop. It is assumed that the operating system supports <q>shebang execution</q>. Also, Python 3 must be available. To compile Maike, a compiler that supports C++17 or later is required. Porting Maike to a POSIX complient system should not be too hard. A native Windows port is probably not possible, since Windows does not support shebang execution.</p>

				<p>Maike benefits from multiple threads. The optimal number of threads depend on the project structure, and I/O capacity compared to CPU performance. It is possible to run maike on a single-threaded machine, but even with only one worker, the multithreaded code is being executed. Thus, this is not ideal.</p>
			</section>

			<section title="Limitations" id="limitations">
				<p>It is not possible to have target files that defines new targets. This limitation comes from the fact that Maike separates the scanning phase from the compilation phase, see <ref item="algo" />. However, this choice also guarantees that everything is correctly setup before the compilation process starts.</p>

				<p>Maike has no native support for optional dependencies. If a project is in need for this functionality, it can be emulated with different configuration files and filename extensions. Also, Maike has no support for <q>feature testing</q> like GNU autoconf.</p>
			</section>

			<section title="Maike compared to other build systems" id="comparison">
				<p>Maike is both a dependency manager and task dispatcher. In that sense, it combines the functionality of CMake and make. A major difference is that Maike reads all dependency information from source files, instead of separate files like CMake, or GNU Automake.</p>
			</section>

		</chapter>
		<chapter title="Installation procedure" id="Installation">
			<section title="From source" id="from_src">
				<ol>
					<li>Download <a href="https://github.com/milasudril/maike/releases/latest/download/maike-src.tar.gz">The latest release</a>
						<pre class="sourceCode">wget https://github.com/milasudril/maike/releases/latest/download/maike-src.tar.gz</pre>
					</li>
					<li>Make sure to install all build dependencies. See <ref item="build_deps" /> for more information.</li>
					<li>Unpack the tarball downloaded in (1)
						<pre class="sourceCode">tar -xf maike-src.tar.gz</pre>
					</li>
					<li>Cd into <code>maike-src</code>
						<pre class="sourceCode">cd maike-src</pre>
					</li>
					<li>Run <code>make</code>
						<pre class="sourceCode">make</pre>
					</li>
					<li><p>Run <code>make</code> with <code>install</code> as target</p>
						<pre class="sourceCode">sudo make install</pre>
						<p>If you do not want to install into <code>/usr</code>, you can set <code>PREFIX</code> to a different directory, i.e.</p>
						<pre class="sourceCode">PREFIX=~/apps make install</pre>
					</li>
				</ol>
			</section>
		</chapter>
		<chapter title="Tagging source files" id="tagging">
			<p>Maike scans for line comments in the form <code><var>comment sequence</var>@</code>. Here <code><var>comment sequence</var></code> is the sequence of characters that starts a comment line in the current language. For C or C++, that would be <code>//</code>. Python and shell scripts would use <code>#</code>. Tags them selfs are written in JSON. Below are two examples. You may find a complete list of the tagging format in <ref item="srctags"/>.</p>
			<pre class="sourceCode">
//@ {
//@ "dependencies_extra":[{"ref":"./source_file_list.o","rel":"implementation"}]
//@ }</pre>
<pre class="sourceCode">
//@ {
//@ "target":{"name":"source_file_list.o"}
//@ }</pre>
<p>Such tags are used to construct the dependency graph, which controls build order and linking. It may happen that you have source files that cannot be easily tagged. For example, you may have some form of binary project files that should be "rendered" into a "consumer" format during the build process. In that case, you may define a static rule in a build configuration file.</p>
		</chapter>
		<chapter title="Using extensions" id="extensions">
		</chapter>
	</main>
	<appendix>
		<chapter title="Command line options" id="cmdlineopts">
			<include src="./cmdlineopts.xml" />
		</chapter>
		<chapter title="Default configuration" id="defaultcfg">
			<include src="./configdefault.xml" />
		</chapter>

		<chapter title="Source file tags" id="srctags">
			<section title="File properties" id="srctags_root">
				<p>File properties controls the use of the current source file. In JSON, they are stored in the root object. File properties include</p>
				<property-list>
					<property name="target"><type>A <ref item="target"/></type><desc>First output file from the compilation command</desc></property>
					<property name="targets"><type>An array of <ref item="target"/>s</type><desc>Other output files from the compilation command</desc></property>
					<property name="dependencies"><type>An array of <ref item="deps">Dependencies</ref></type><desc>Dependencies that must be satisfied before the file can be compiled</desc></property>
					<property name="dependencies_extra"><type>An array of <ref item="deps">Dependencies</ref></type><desc>Dependencies that should be appendend to any <ref item="target"/> that is using this file during compilation. The typical usecase is to refer to object files from include files, so that linking a program will work automatically.</desc></property>
					<property name="compiler"><type><ref item="compiler_opts"/></type><desc>Compiler configurations specific to this file</desc></property>
					<property name="rebuild"><type>string</type><desc><p>Determines the policy used to decide whether or not the source file should be recompiled. It may take one of the following values:</p><enum>
								<item name="always">Always recompile this file</item>
								<item name="only_if_out_of_date">Only recompile this file if it is not up-to-date</item>
								</enum>
								<p>If not present, <code>only_if_out_of_date</code> is used.</p></desc></property>
				</property-list>
			</section>

			<section title="Target" id="target">
				<p>A <code>Target</code> represents one output file of a compilation command. A target has the following properties:</p>
				<property-list>
					<property name="name"><type>string</type><desc>The name of the output file</desc></property>
					<property name="dependencies"><type>An array of <ref item="deps">dependencies</ref></type><desc>Dependencies that must be satisfied before this target can be used as a source file. Typically, it refers to external libraries that should be used during linking of a program.</desc></property>
					<property name="pkgconfig_libs"><type>An array of strings</type><desc>A list of libraries known to <manpage name="pkg-config" section="1"/>, that should be used for linking.</desc></property>
				</property-list>
			</section>

			<section title="Dependency" id="deps">
				<p>A <code>Dependency</code> describes a relation between a source file or target, and other entities. A dependency has the following properties:</p>
				<property-list>
					<property name="ref"><type>string</type><desc>The name referenced resource. To refer to a file in the same directory as current file, the prefix <code>./</code> has to be used. Otherwise, the resource path will be treated as relative to the project directory.</desc></property>
					<property name="origin"><type>string</type><desc>The expected origin of the resource referred to by <var>ref</var>. It may be set to one of the following values:<enum>
								<item name="generated">The resource will be generated during compilation of the project</item>
								<item name="project">The resource is a static resource stored within the project</item>
								<item name="system">The resource is a static resource stored outside of the project</item>
								<item name="pkg-config">The resource is a static resource that should be looked up by <manpage name="pkg-config" section="1"/></item>
								</enum></desc></property>
					<property name="…"><type><var>recipe specific</var></type><desc>Additional data that may be used by built recipes</desc></property>
				</property-list>
			</section>

			<section title="Compiler configuration" id="compiler_opts">
				<p>Compiler configurations are used to configure a build recipe or compiler. It contains the following properties:</p>
				<property-list>
					<property name="recipe"><type>string</type><desc>The recipe file<!--reference to section--> to run when compiling a source file mapped to this compiler configuration</desc></property>
					<property name="config"><type>object</type><desc>Additional data for use by the recipe file</desc></property>
					<property name="use_get_tags"><type>int</type><desc>If this value is non-zero, Maike will use the recipe file to extract additional tags from the current source file. This is useful in case a project contains some files which Maike does not know how to extract dependencies from. Since this process involves extra overhead, it is turned off by default.</desc></property>
				</property-list>
			</section>

		</chapter>
		<chapter title="Recipe commands" id="commands">
		</chapter>
		<chapter title="Compilation log format" id="compilation_log">
		</chapter>
		<chapter title="Build dependencies" id="build_deps">
		</chapter>
		<chapter title="Porting Maike 1.0 projects to Maike 2.0" id="changes_v1_v2"/>
		<chapter title="Schematics" id="schematics">
			<section title="Components" id="components">
				<img src="./components.svg" />
			</section>

			<section title="Processing algorithms" id="algo">
				<img src="./pipeline.svg" />

				<subsection title="Initialize" id="init">
					<img src="./initialize.svg" />
					<subsubsection title="Resolve recipes" id="resolve_recipes">
						<img src="./resolve_recipes.svg" />
					</subsubsection>
				</subsection>

				<subsection title="Load source tree" id="load_src_tree">
					<img src="./load_source_tree.svg" />

					<subsubsection title="Source tree loader" id="src_tree_loader">
						<img src="./source_tree_loader.svg" />

						<paragraph title="Use entry" id="use_entry">
							<p>This is some text, lol</p>
							<p><img src="./use_entry.svg" /></p>
						</paragraph>
					</subsubsection>

					<subsubsection title="Make dependency graph" id="load_dep_graph">
						<img src="./make_dep_graph.svg" />
					</subsubsection>
				</subsection>

				<subsection title="Compile project" id="compile">
					<img src="./compile.svg" />

					<subsubsection title="Create task list" id="create_task_list">
						<img src="./create_task_list.svg" />
						<paragraph title="Create task"  id="create_task">
							<p><img src="./create_task.svg"/></p>
						</paragraph>
					</subsubsection>

					<subsection title="Process task list" id="process_task_list">
						<img src="./process_task_list.svg" />
					</subsection>
				</subsection>
			</section>
		</chapter>
	</appendix>
</document>
